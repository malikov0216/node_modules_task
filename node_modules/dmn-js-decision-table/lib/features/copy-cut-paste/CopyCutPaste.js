var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import { isArray } from 'min-dash';

import CutHandler from './cmd/CutHandler';
import PasteHandler from './cmd/PasteHandler';

import { createDescriptor } from './DescriptorUtil';

var CutPaste = function () {
  function CutPaste(clipboard, commandStack, eventBus, modeling, sheet, rules) {
    _classCallCheck(this, CutPaste);

    this._clipboard = clipboard;
    this._commandStack = commandStack;
    this._eventBus = eventBus;
    this._modeling = modeling;
    this._sheet = sheet;
    this._rules = rules;

    commandStack.registerHandler('cut', CutHandler);
    commandStack.registerHandler('paste', PasteHandler);
  }

  /**
   * Copy elements.
   *
   * @param {Array} elements - Elements to be copied.
   */


  _createClass(CutPaste, [{
    key: 'copy',
    value: function copy(elements) {
      if (!isArray(elements)) {
        elements = [elements];
      }

      var data = {
        elements: createDescriptor(elements)
      };

      this._eventBus.fire('copyCutPaste.copy', { data: data });

      this._clipboard.set(data);
    }

    /**
     * Cut elements thereby removing them temporarily.
     *
     * @param {Array} elements - Elements to be cut.
     */

  }, {
    key: 'cut',
    value: function cut(elements) {
      if (!isArray(elements)) {
        elements = [elements];
      }

      var data = {
        elements: createDescriptor(elements),
        keepIds: true
      };

      var context = {
        elements: elements,
        data: data
      };

      this._eventBus.fire('copyCutPaste.cut', { data: data });

      this._commandStack.execute('cut', context);
    }

    /**
     * Paste rows or cols before row or col.
     *
     * @param {Row|Col} element - Row or col to paste elements before.
     */

  }, {
    key: 'pasteBefore',
    value: function pasteBefore(element) {
      return this._paste(element, { before: true });
    }

    /**
     * Paste rows or cols after row or col.
     *
     * @param {Row|Col} element - Row or col to paste elements after.
     */

  }, {
    key: 'pasteAfter',
    value: function pasteAfter(element) {
      return this._paste(element, { after: true });
    }

    /**
     * Basic paste onto given target element.
     */

  }, {
    key: '_paste',
    value: function _paste(target, position) {

      var clipboardData = this._clipboard.get();

      if (!clipboardData) {
        return undefined;
      }

      var allowed = this._rules.allowed('paste', {
        data: clipboardData.elements,
        target: target
      });

      if (!allowed) {
        return false;
      }

      this._commandStack.execute('paste', _extends({
        element: target
      }, position));

      return true;
    }

    /**
     * Paste elements at.
     */

  }, {
    key: 'pasteAt',
    value: function pasteAt(element) {
      // TODO: implement for pasting cells
    }
  }]);

  return CutPaste;
}();

export default CutPaste;


CutPaste.$inject = ['clipboard', 'commandStack', 'eventBus', 'modeling', 'sheet', 'rules'];
//# sourceMappingURL=CopyCutPaste.js.map