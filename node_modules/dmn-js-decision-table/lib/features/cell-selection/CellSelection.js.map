{"version":3,"sources":["../../../src/features/cell-selection/CellSelection.js"],"names":["ensureFocus","findSelectableAncestor","getElementCoords","getElementId","getNodeByCoords","getNodeById","isUnselectableNode","LOW_PRIORITY","VALID_DIRECTIONS","above","below","right","left","CellSelection","config","eventBus","sheet","selection","elementRegistry","container","lastSelection","emit","elementId","newSelection","fire","click","event","target","selectableNode","focussed","defaultPrevented","realSelect","stopPropagation","focus","unfocus","selected","select","deselect","on","actualElement","oldSelection","id","oldElementId","isCellSelected","getCellSelection","selectCell","direction","Error","selectionEl","coords","nextCoords","getNextCoords","nextNode","nextElId","$inject","row","col","rowIndex","parseInt","isNaN","nextRowIndex","colIndex","nextColIndex"],"mappings":"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","file":"CellSelection.js","sourcesContent":["import {\n  ensureFocus,\n  findSelectableAncestor,\n  getElementCoords,\n  getElementId,\n  getNodeByCoords,\n  getNodeById,\n  isUnselectableNode\n} from './CellSelectionUtil';\n\nconst LOW_PRIORITY = 500;\n\nconst VALID_DIRECTIONS = {\n  above: true,\n  below: true,\n  right: true,\n  left: true\n};\n\n\n/**\n * A cell selection utlity; allows selection of elements, independent from\n * whether they are backed by a business object or not.\n *\n * Works together with the {@link SelectionAware} trait.\n *\n * @param {RenderConfig} config\n * @param {EventBus} eventBus\n * @param {Sheet} sheet\n * @param {Selection} selection\n * @param {ElementRegistry} elementRegistry\n */\nexport default function CellSelection(\n    config, eventBus, sheet,\n    selection, elementRegistry) {\n\n  const {\n    container\n  } = config;\n\n  let lastSelection = null;\n\n  function emit(elementId, newSelection) {\n\n    eventBus.fire('selection.' + elementId + '.changed', newSelection);\n\n    eventBus.fire('cellSelection.changed', {\n      elementId: elementId,\n      selection: newSelection\n    });\n\n  }\n\n  function click(event) {\n\n    const target = event.target;\n\n    if (isUnselectableNode(target)) {\n      return;\n    }\n\n    const selectableNode = findSelectableAncestor(target);\n\n    const elementId = selectableNode && getElementId(selectableNode);\n\n    const focussed = !event.defaultPrevented;\n\n    realSelect(elementId, focussed);\n\n    event.stopPropagation();\n  }\n\n  function focus(event) {\n    const elementId = getElementId(event.target);\n\n    const focussed = !event.defaultPrevented;\n\n    event.stopPropagation();\n\n    return realSelect(elementId, focussed);\n  }\n\n  function unfocus(event) {\n    const elementId = getElementId(event.target);\n\n    emit(elementId, {\n      focussed: false\n    });\n  }\n\n  function realSelect(elementId, focussed = true) {\n\n    if (lastSelection !== elementId) {\n      emit(lastSelection, {\n        selected: false,\n        focussed: false\n      });\n    }\n\n    lastSelection = elementId;\n\n    if (elementId) {\n      emit(elementId, {\n        selected: true,\n        focussed\n      });\n    }\n\n    if (elementId) {\n      selection.select(elementId);\n    } else {\n      selection.deselect();\n    }\n  }\n\n  eventBus.on('cell.click', LOW_PRIORITY, click);\n  eventBus.on('cell.focusin', LOW_PRIORITY, focus);\n  eventBus.on('cell.focusout', LOW_PRIORITY, unfocus);\n\n  eventBus.on('cellSelection.changed', function(event) {\n\n    const {\n      elementId,\n      selection\n    } = event;\n\n    const actualElement = getNodeById(elementId, container);\n\n    if (selection.focussed && actualElement) {\n      ensureFocus(actualElement);\n    }\n  });\n\n  eventBus.on('selection.changed', function(event) {\n\n    const {\n      selection,\n      oldSelection\n    } = event;\n\n    var elementId = selection && selection.id;\n    var oldElementId = oldSelection && oldSelection.id;\n\n    // select new element\n    if (elementId && elementId !== lastSelection) {\n      realSelect(selection.id);\n    } else\n\n    // deselect old element\n    if (oldElementId && oldElementId === lastSelection) {\n      realSelect();\n    }\n\n  });\n\n  // API //////////////////////\n\n  /**\n   * Return true if a cell is currently selected.\n   *\n   * @return {Boolean}\n   */\n  this.isCellSelected = function() {\n    return !!lastSelection;\n  };\n\n  /**\n   * Get the currently active cellSelection.\n   *\n   * @return {String} selection\n   */\n  this.getCellSelection = function() {\n    return lastSelection;\n  };\n\n  /**\n   * Select next cell in given direction.\n   *\n   * Returns true on success; false on fail (i.e. if no next selection\n   * in direction could be found).\n   *\n   * @param {String} direction\n   *\n   * @return {Boolean}\n   */\n  this.selectCell = function(direction) {\n\n    if (!lastSelection) {\n      return;\n    }\n\n    if (!(direction in VALID_DIRECTIONS)) {\n      throw new Error('direction must be any of { above, below, left, right }');\n    }\n\n    var selectionEl = getNodeById(lastSelection, container);\n\n    const coords = getElementCoords(selectionEl);\n\n    if (!coords) {\n      return false;\n    }\n\n    const nextCoords = getNextCoords(coords, direction);\n\n    const nextNode = getNodeByCoords(nextCoords, container);\n\n    if (!nextNode) {\n      return false;\n    }\n\n    const nextElId = getElementId(nextNode);\n\n    if (nextElId) {\n      realSelect(nextElId, {\n        focussed: true,\n        selected: true\n      });\n    }\n\n    return true;\n  };\n\n\n  eventBus.on('contextMenu.close', function() {\n\n    if (lastSelection) {\n      return realSelect(lastSelection);\n    }\n\n  });\n\n}\n\nCellSelection.$inject = [\n  'config.renderer',\n  'eventBus',\n  'sheet',\n  'selection',\n  'elementRegistry'\n];\n\n\n\n// helpers ////////////////\n\nfunction getNextCoords(coords, direction) {\n\n  const {\n    row,\n    col\n  } = coords;\n\n  if (direction === 'above' || direction === 'below') {\n\n    const rowIndex = parseInt(row, 10);\n\n    if (isNaN(rowIndex)) {\n      return coords;\n    }\n\n    const nextRowIndex = direction === 'above' ? rowIndex - 1 : rowIndex + 1;\n\n    return {\n      col,\n      row: nextRowIndex\n    };\n  }\n\n  if (direction === 'left' || direction === 'right') {\n\n    const colIndex = parseInt(col, 10);\n\n    if (isNaN(colIndex)) {\n      return coords;\n    }\n\n    const nextColIndex = direction === 'left' ? colIndex - 1 : colIndex + 1;\n\n    return {\n      row,\n      col: nextColIndex\n    };\n  }\n\n  throw new Error('invalid direction <' + direction + '>');\n}"]}