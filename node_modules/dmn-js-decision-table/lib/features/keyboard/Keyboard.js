var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import { event as domEvent } from 'min-dom';

import { findSelectableAncestor } from '../cell-selection/CellSelectionUtil';

import { isCmd, isShift } from './KeyboardUtil';

/**
 * A keyboard abstraction that may be activated and
 * deactivated by users at will, consuming key events
 * and triggering diagram actions.
 *
 * The implementation fires the following key events that allow
 * other components to hook into key handling:
 *
 *  - keyboard.bind
 *  - keyboard.unbind
 *  - keyboard.init
 *  - keyboard.destroy
 *
 * All events contain the fields (node, listeners).
 *
 * A default binding for the keyboard may be specified via the
 * `keyboard.bindTo` configuration option.
 *
 * @param {Config} config
 * @param {EventBus} eventBus
 * @param {EditorActions} editorActions
 */

var Keyboard = function () {
  function Keyboard(config, eventBus, editorActions) {
    var _this = this;

    _classCallCheck(this, Keyboard);

    this._init = function () {
      _this._registerDefaultBindings();

      _this._fire('init');
    };

    this._destroy = function () {
      _this._fire('destroy');

      _this.unbind();
      _this._listeners = null;
    };

    this._keyHandler = function (event) {

      var i,
          l,
          listeners = _this._listeners,
          code = event.keyCode || event.charCode || -1;

      for (i = 0; l = listeners[i]; i++) {
        if (l(code, event)) {
          event.preventDefault();
          event.stopPropagation();

          return;
        }
      }
    };

    this.unbind = function () {
      var node = _this._node;

      if (node) {
        _this._fire('unbind');

        // unbind key events
        domEvent.unbind(node, 'keydown', _this._keyHandler, true);
      }

      _this._node = null;
    };

    this._config = config || {};
    this._editorActions = editorActions;
    this._eventBus = eventBus;

    this._listeners = [];

    eventBus.on('table.destroy', this._destroy);
    eventBus.on('table.init', this._init);

    eventBus.on('attach', function () {

      if (_this._config.bindTo) {
        _this.bind(config.bindTo);
      }
    });

    eventBus.on('detach', this.unbind);
  }

  // our key handler is a singleton that passes
  // (keycode, modifiers) to each listener.
  //
  // listeners must indicate that they handled a key event
  // by returning true. This stops the event propagation.
  //


  _createClass(Keyboard, [{
    key: 'bind',
    value: function bind(node) {
      // make sure that the keyboard is only bound once to the DOM
      this.unbind();

      this._node = node;

      // bind key events
      domEvent.bind(node, 'keydown', this._keyHandler, true);

      this._fire('bind');
    }
  }, {
    key: 'getBinding',
    value: function getBinding() {
      return this._node;
    }
  }, {
    key: '_fire',
    value: function _fire(event) {
      this._eventBus.fire('keyboard.' + event, {
        node: this._node,
        listeners: this._listeners
      });
    }
  }, {
    key: '_registerDefaultBindings',
    value: function _registerDefaultBindings() {

      var listeners = this._listeners;

      var editorActions = this._editorActions;

      // init default listeners

      // undo
      // (CTRL|CMD) + Z
      function undo(key, modifiers) {

        if (isCmd(modifiers) && !isShift(modifiers) && key === 90) {
          editorActions.trigger('undo');

          return true;
        }
      }

      // redo
      // CTRL + Y
      // CMD + SHIFT + Z
      function redo(key, modifiers) {

        if (isCmd(modifiers) && (key === 89 || key === 90 && isShift(modifiers))) {
          editorActions.trigger('redo');

          return true;
        }
      }

      listeners.push(undo);
      listeners.push(redo);

      function selectCell(key, event) {

        if (key !== 13 || isCmd(event)) {
          return;
        }

        if (!findSelectableAncestor(event.target)) {
          return;
        }

        var cmd = isShift(event) ? 'selectCellAbove' : 'selectCellBelow';

        editorActions.trigger(cmd);

        return true;
      }

      listeners.push(selectCell);
    }

    /**
     * Add a listener function that is notified with (key, modifiers) whenever
     * the keyboard is bound and the user presses a key.
     *
     * @param {Function} listenerFn
     */

  }, {
    key: 'addListener',
    value: function addListener(listenerFn) {
      this._listeners.unshift(listenerFn);
    }
  }, {
    key: 'removeListener',
    value: function removeListener(listenerFn) {
      this._listeners = this._listeners.filter(function (l) {
        return l !== listenerFn;
      });
    }
  }]);

  return Keyboard;
}();

export default Keyboard;


Keyboard.$inject = ['config.keyboard', 'eventBus', 'editorActions'];
//# sourceMappingURL=Keyboard.js.map