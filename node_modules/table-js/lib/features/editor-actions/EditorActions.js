var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import { forEach } from 'min-dash';

var NOT_REGISTERED_ERROR = 'is not a registered action',
    IS_REGISTERED_ERROR = 'is already registered';

/**
 * An interface that provides access to modeling actions by decoupling
 * the one who requests the action to be triggered and the trigger itself.
 *
 * It's possible to add new actions by registering them with ´registerAction´ and likewise
 * unregister existing ones with ´unregisterAction´.
 *
 */

var EditorActions = function () {
  function EditorActions(commandStack, eventBus, modeling, selection) {
    _classCallCheck(this, EditorActions);

    this._actions = {
      undo: function undo() {
        commandStack.undo();
      },
      redo: function redo() {
        commandStack.redo();
      },
      select: function select(_ref) {
        var cell = _ref.cell;

        selection.select(cell);
      },
      deselect: function deselect() {
        selection.deselect();
      },
      addRow: function addRow(_ref2) {
        var attrs = _ref2.attrs,
            index = _ref2.index;

        modeling.addRow(attrs, index);
      },
      removeRow: function removeRow(_ref3) {
        var row = _ref3.row;

        modeling.removeRow(row);
      },
      moveRow: function moveRow(_ref4) {
        var row = _ref4.row,
            index = _ref4.index;

        modeling.moveRow(row, index);
      },
      addCol: function addCol(_ref5) {
        var attrs = _ref5.attrs,
            index = _ref5.index;

        modeling.addCol(attrs, index);
      },
      removeCol: function removeCol(_ref6) {
        var col = _ref6.col;

        modeling.removeCol(col);
      },
      moveCol: function moveCol(_ref7) {
        var col = _ref7.col,
            index = _ref7.index;

        modeling.moveCol(col, index);
      }
    };
  }

  /**
   * Triggers a registered action
   *
   * @param  {String} action
   * @param  {Object} opts
   *
   * @return {Unknown} Returns what the registered listener returns
   */


  _createClass(EditorActions, [{
    key: 'trigger',
    value: function trigger(action, opts) {
      if (!this._actions[action]) {
        throw error(action, NOT_REGISTERED_ERROR);
      }

      return this._actions[action](opts);
    }

    /**
     * Registers a collections of actions.
     * The key of the object will be the name of the action.
     *
     * @param  {Object} actions
     */

  }, {
    key: 'register',
    value: function register(actions, listener) {
      var _this = this;

      if (typeof actions === 'string') {
        return this._registerAction(actions, listener);
      }

      forEach(actions, function (listener, action) {
        _this._registerAction(action, listener);
      }, this);
    }

    /**
     * Registers a listener to an action key
     *
     * @param  {String} action
     * @param  {Function} listener
     */

  }, {
    key: '_registerAction',
    value: function _registerAction(action, listener) {
      if (this.isRegistered(action)) {
        throw error(action, IS_REGISTERED_ERROR);
      }

      this._actions[action] = listener;
    }

    /**
     * Unregister an existing action
     *
     * @param {String} action
     */

  }, {
    key: 'unregister',
    value: function unregister(action) {
      if (!this.isRegistered(action)) {
        throw error(action, NOT_REGISTERED_ERROR);
      }

      this._actions[action] = undefined;
    }

    /**
     * Checks wether the given action is registered
     *
     * @param {String} action
     *
     * @return {Boolean}
     */

  }, {
    key: 'isRegistered',
    value: function isRegistered(action) {
      return !!this._actions[action];
    }
  }]);

  return EditorActions;
}();

export default EditorActions;


EditorActions.$inject = ['commandStack', 'eventBus', 'modeling', 'selection'];

// helpers /////////////

function error(action, message) {
  return new Error(action + ' ' + message);
}
//# sourceMappingURL=EditorActions.js.map