var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

import { createVNode, createComponentVNode } from 'inferno';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

import { Component } from 'inferno';

import { assign, isFunction } from 'min-dash';

import { inject } from '../../../components';

import { query as domQuery } from 'min-dom';

import { setRange } from 'selection-ranges';

var ContextMenuComponent = function (_Component) {
  _inherits(ContextMenuComponent, _Component);

  function ContextMenuComponent(props, context) {
    _classCallCheck(this, ContextMenuComponent);

    var _this = _possibleConstructorReturn(this, (ContextMenuComponent.__proto__ || Object.getPrototypeOf(ContextMenuComponent)).call(this, props, context));

    _initialiseProps.call(_this);

    _this.state = {
      isOpen: false,
      position: {
        x: 0,
        y: 0
      }
    };

    inject(_this);
    return _this;
  }

  /**
   * Open the context menu with given position and context.
   *
   * The menu itself will figure out the best position, taking the optional
   * positioning parameter into account.
   *
   * @param {Bounds|Point} position
   * @param {Object} [context]
   */


  /**
   * Closes context menu and resets state.
   */


  _createClass(ContextMenuComponent, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.eventBus.on('contextMenu.open', this.open);
      this.eventBus.on('contextMenu.close', this.close);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.eventBus.off('contextMenu.open', this.open);
      this.eventBus.off('contextMenu.close', this.close);
    }
  }, {
    key: 'render',
    value: function render() {
      var _state = this.state,
          isOpen = _state.isOpen,
          context = _state.context,
          position = _state.position;


      if (!isOpen) {
        return null;
      }

      var components = this.components.getComponents('context-menu', context);

      if (!components.length) {
        return null;
      }

      return createComponentVNode(2, ContextMenu, {
        'className': 'context-menu no-deselect',
        'context': context,
        'position': position,
        'offset': context.offset || { x: 0, y: 0 },
        'autoFocus': context.autoFocus !== false,
        'autoClose': context.autoClose !== false,
        'components': components,
        'onClose': this.triggerClose
      });
    }
  }]);

  return ContextMenuComponent;
}(Component);

var _initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this.open = function (_ref) {
    var position = _ref.position,
        context = _ref.context;


    // always close first
    _this2.close();

    _this2.setState({
      isOpen: true,
      position: position || { x: 0, y: 0 },
      context: context || {}
    });
  };

  this.close = function () {

    if (_this2.state.isOpen) {
      _this2.setState({
        context: undefined,
        isOpen: false,
        position: {
          x: 0,
          y: 0
        }
      });
    }
  };

  this.triggerClose = function () {
    _this2.eventBus.fire('contextMenu.close');
  };
};

export default ContextMenuComponent;


ContextMenuComponent.$inject = ['eventBus', 'components'];

/**
 * Low-level, stateless context menu holder.
 */

var ContextMenu = function (_Component2) {
  _inherits(ContextMenu, _Component2);

  function ContextMenu(props, context) {
    _classCallCheck(this, ContextMenu);

    var _this3 = _possibleConstructorReturn(this, (ContextMenu.__proto__ || Object.getPrototypeOf(ContextMenu)).call(this, props, context));

    _this3.onGlobalClick = function (event) {
      _this3.checkClose(event.target);
    };

    _this3.onGlobalKey = function (event) {

      var keyCode = event.which;

      // ENTER or ESC
      if (keyCode === 13 || keyCode === 27) {
        event.stopPropagation();
        event.preventDefault();

        _this3.close();
      }
    };

    _this3.onFocusChanged = function (event) {
      _this3.checkClose(event.target);
    };

    _this3.setNode = function (node) {
      _this3.node = node;

      var autoFocus = _this3.props.autoFocus;


      if (node) {

        if (autoFocus) {
          ensureFocus(node);
        }

        _this3.updatePosition();
      }
    };

    inject(_this3);
    return _this3;
  }

  _createClass(ContextMenu, [{
    key: 'close',
    value: function close() {
      var onClose = this.props.onClose;


      if (isFunction(onClose)) {
        onClose();
      }
    }

    /**
     * Check whether closing the context menu is necessary
     * after selecting the given element.
     */

  }, {
    key: 'checkClose',
    value: function checkClose(focusTarget) {
      var autoClose = this.props.autoClose;


      if (!autoClose) {
        return;
      }

      var node = this.node;

      if (!node) {
        return;
      }

      if (node === focusTarget) {
        return;
      }

      if (node.contains(focusTarget)) {
        return;
      }

      this.close();
    }

    /**
     * Handle global (window) click event.
     */


    /**
     * Handle global key event.
     */


    /**
     * Handle global (document) focus changed event.
     */

  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      document.addEventListener('focusin', this.onFocusChanged);
      document.addEventListener('keydown', this.onGlobalKey);
      document.addEventListener('click', this.onGlobalClick);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      document.removeEventListener('focusin', this.onFocusChanged);
      document.removeEventListener('keydown', this.onGlobalKey);
      document.removeEventListener('click', this.onGlobalClick);
    }
  }, {
    key: 'updatePosition',


    /**
     * Find best context menu position and re-layout accordingly.
     */
    value: function updatePosition() {
      var _props = this.props,
          position = _props.position,
          offset = _props.offset;


      var bounds = this.node.getBoundingClientRect();

      if (!position.width) {
        position.width = 0;
      }

      if (!position.height) {
        position.height = 0;
      }

      var container = this.renderer.getContainer();

      var containerBounds = container.getBoundingClientRect();

      if (containerBounds.width > containerBounds.height) {
        this.node.classList.add('horizontal');
        this.node.classList.remove('vertical');
      } else {
        this.node.classList.add('vertical');
        this.node.classList.remove('horizontal');
      }

      var scrollLeft = container.scrollLeft,
          scrollTop = container.scrollTop;


      var style = {};

      if (position.x + position.width / 2 > containerBounds.width / 2) {
        var left = position.x - containerBounds.left - bounds.width + offset.x + scrollLeft;

        left = clampNumber(left, 0 + scrollLeft, containerBounds.width - bounds.width + scrollLeft);

        style.left = left + 'px';
      } else {
        var _left = window.scrollX - containerBounds.left + position.x + position.width - offset.x + scrollLeft;

        _left = clampNumber(_left, 0 + scrollLeft, containerBounds.width - bounds.width + scrollLeft);

        style.left = _left + 'px';
      }

      var top = void 0;

      if (position.y + position.height / 2 > containerBounds.height / 2) {
        top = position.y - containerBounds.top - bounds.height + offset.y + scrollTop;

        top = clampNumber(top, 0 + scrollTop, containerBounds.height - bounds.height + scrollTop);

        style.top = top + 'px';
      } else {
        top = window.scrollY - containerBounds.top + position.y - offset.y + scrollTop;

        top = clampNumber(top, 0 + scrollTop, containerBounds.height - bounds.height + scrollTop);

        style.top = top + 'px';
      }

      // ensure context menu will always be accessible
      style.overflowY = 'auto';
      style.maxHeight = containerBounds.height - top + scrollTop + 'px';

      assign(this.node.style, style);
    }
  }, {
    key: 'render',
    value: function render() {
      var _props2 = this.props,
          context = _props2.context,
          components = _props2.components,
          className = _props2.className;


      return createVNode(1, 'div', className, components.map(function (Component, idx) {
        return createComponentVNode(2, Component, {
          'context': context
        }, idx);
      }), 0, {
        'onContextMenu': function onContextMenu(e) {
          return e.preventDefault();
        }
      }, null, this.setNode);
    }
  }]);

  return ContextMenu;
}(Component);

ContextMenu.$inject = ['renderer'];

// helpers /////////////

function clampNumber(number, min, max) {
  return Math.max(min, Math.min(max, number));
}

var SELECTABLE_ELEMENTS = '\n  input[type=text],\n  input[type=number],\n  input[type=button],\n  input[type=submit],\n  [contenteditable],\n  [tabindex],\n  a[href],\n  textarea,\n  button\n';

function ensureFocus(el) {

  var focusEl = domQuery(SELECTABLE_ELEMENTS, el);

  if (focusEl) {
    focusEl.focus();

    // inputs
    if (focusEl.selectionStart && focusEl.type === 'text') {
      focusEl.selectionStart = 100000;
    } else

      // content editable elements
      if ('contentEditable' in focusEl) {
        setRange(focusEl, { start: 100000, end: 100000 });
      }
  }
}
//# sourceMappingURL=ContextMenuComponent.js.map