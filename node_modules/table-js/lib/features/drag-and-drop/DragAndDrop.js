var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import { Row, Col } from '../../model';

import { closest as domClosest, event as domEvent } from 'min-dom';

var TARGET_SELECTOR = '.dmn-decision-table-container td,\n   .dmn-decision-table-container th';

var DragAndDrop = function () {
  function DragAndDrop(eventBus, renderer, modeling, sheet) {
    var _this = this;

    _classCallCheck(this, DragAndDrop);

    this.handleDragOver = function (event) {

      // we're taking over (!)
      stopEvent(event);

      var targetEl = event.target;

      var cellEl = domClosest(targetEl, TARGET_SELECTOR, true);

      var allowed = !!cellEl;

      var hoverEl = _this._dragContext.hoverEl;

      // drag leave

      if (hoverEl && hoverEl !== cellEl) {
        _this._emit('dragAndDrop.dragLeave', event);

        // unset target element
        _this._dragContext.targetEl = null;

        // unset hover element
        _this._dragContext.hoverEl = null;
      }

      if (cellEl) {

        // drag enter
        if (cellEl !== hoverEl) {

          // new hover element
          _this._dragContext.hoverEl = cellEl;

          allowed = _this._emit('dragAndDrop.dragEnter', event);

          if (allowed !== false) {
            // new targetEl
            _this._dragContext.targetEl = cellEl;
          }
        }

        // drag over
        allowed = _this._emit('dragAndDrop.dragOver', event);
      }

      event.dataTransfer.dropEffect = allowed !== false ? 'move' : 'none';
    };

    this.handleDrop = function (event) {

      // prevent default drop action
      // QUIRK: Firefox will redirect if not prevented
      stopEvent(event);

      var target = _this._emit('dragAndDrop.drop', event);

      if (target) {
        var draggedElement = _this._dragContext.draggedElement;


        if (draggedElement instanceof Row) {
          var _sheet$getRoot = _this._sheet.getRoot(),
              rows = _sheet$getRoot.rows;

          var index = rows.indexOf(target);

          _this._modeling.moveRow(draggedElement, index);
        } else if (draggedElement instanceof Col) {
          var _sheet$getRoot2 = _this._sheet.getRoot(),
              cols = _sheet$getRoot2.cols;

          var _index = cols.indexOf(target);

          _this._modeling.moveCol(draggedElement, _index);
        }
      }

      // manually call to drag end needed, as we prevent the default
      // browser behavior / drag end handling via
      // event.preventDefault();
      _this.handleDragEnd(event);
    };

    this.handleDragEnd = function (event) {

      // prevent default drop action
      stopEvent(event);

      _this._unbindListeners();
      _this._emit('dragAndDrop.dragEnd', event);

      _this._dragContext = null;
    };

    this._eventBus = eventBus;
    this._renderer = renderer;
    this._modeling = modeling;
    this._sheet = sheet;

    this._dragContext = null;

    eventBus.on('table.destroy', function () {
      _this._unbindListeners();
    });
  }

  _createClass(DragAndDrop, [{
    key: '_bindListeners',
    value: function _bindListeners() {
      domEvent.bind(document, 'dragover', this.handleDragOver);
      domEvent.bind(document, 'drop', this.handleDrop);
      domEvent.bind(document, 'dragend', this.handleDragEnd);
    }
  }, {
    key: '_unbindListeners',
    value: function _unbindListeners() {
      domEvent.unbind(document, 'dragover', this.handleDragOver);
      domEvent.unbind(document, 'drop', this.handleDrop);
      domEvent.unbind(document, 'dragend', this.handleDragEnd);
    }
  }, {
    key: '_emit',
    value: function _emit(eventName, originalEvent) {

      return this._eventBus.fire(eventName, {
        dragContext: this._dragContext,
        originalEvent: originalEvent
      });
    }
  }, {
    key: 'startDrag',
    value: function startDrag(element, event) {

      stopEvent(event, true);

      event.dataTransfer.effectAllowed = 'move';

      // QUIRK: Firefox won't fire events unless data was set
      if (event.dataTransfer.setData) {
        event.dataTransfer.setData('text', '__DUMMY');
      }

      this._dragContext = {
        draggedElement: element
      };

      this._bindListeners();

      this._emit('dragAndDrop.dragStart', event);
    }
  }]);

  return DragAndDrop;
}();

export default DragAndDrop;


DragAndDrop.$inject = ['eventBus', 'renderer', 'modeling', 'sheet'];

// helpers /////////////////

function stopEvent(event, preventDefault) {
  event.stopPropagation();

  if (preventDefault !== true) {
    event.preventDefault();
  }
}
//# sourceMappingURL=DragAndDrop.js.map