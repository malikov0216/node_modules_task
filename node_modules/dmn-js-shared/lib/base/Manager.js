var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import EventBus from 'diagram-js/lib/core/EventBus';

import DmnModdle from 'dmn-moddle';

import { domify, query as domQuery, remove as domRemove } from 'min-dom';

import { assign, debounce, isNumber } from 'min-dash';

var DEFAULT_CONTAINER_OPTIONS = {
  width: '100%',
  height: '100%',
  position: 'relative'
};

/**
 * The base class for DMN viewers and editors.
 *
 * @abstract
 */

var Manager = function () {

  /**
   * Create a new instance with the given options.
   *
   * @param  {Object} options
   *
   * @return {Manager}
   */
  function Manager() {
    var _this = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Manager);

    this._viewsChanged = function () {
      _this._emit('views.changed', {
        views: _this._views,
        activeView: _this._activeView
      });
    };

    this._eventBus = new EventBus();

    this._viewsChanged = debounce(this._viewsChanged, 0);

    this._views = [];
    this._viewers = {};

    this._init(options);
  }

  /**
   * Parse and render a DMN 1.1 diagram.
   *
   * Once finished the viewer reports back the result to the
   * provided callback function with (err, warnings).
   *
   * ## Life-Cycle Events
   *
   * During import the viewer will fire life-cycle events:
   *
   *   * import.parse.start (about to read model from xml)
   *   * import.parse.complete (model read; may have worked or not)
   *   * import.render.start (graphical import start)
   *   * import.render.complete (graphical import finished)
   *   * import.done (everything done)
   *
   * You can use these events to hook into the life-cycle.
   *
   * @param {String} xml the DMN 1.1 xml
   * @param {Object} [options]
   * @param {Boolean} [options.open=true]
   * @param {Function} [done] invoked with (err, warnings=[])
   */


  _createClass(Manager, [{
    key: 'importXML',
    value: function importXML(xml, options, done) {
      var _this2 = this;

      if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') {
        done = options;
        options = { open: true };
      }

      if (typeof done !== 'function') {
        done = noop;
      }

      // hook in pre-parse listeners +
      // allow xml manipulation
      xml = this._emit('import.parse.start', { xml: xml }) || xml;

      this._moddle.fromXML(xml, 'dmn:Definitions', function (err, definitions, context) {

        // hook in post parse listeners +
        // allow definitions manipulation
        definitions = _this2._emit('import.parse.complete', {
          error: err,
          definitions: definitions,
          context: context
        }) || definitions;

        var parseWarnings = context.warnings;

        _this2._setDefinitions(definitions);

        if (err) {
          err = checkValidationError(err);
        }

        if (err || !options.open) {
          _this2._emit('import.done', { error: err, warmings: parseWarnings });

          return done(err, parseWarnings);
        }

        var view = _this2._activeView || _this2._getInitialView(_this2._views);

        if (!view) {
          return done(new Error('no displayable contents'));
        }

        _this2.open(view, function (err, warnings) {

          var allWarnings = [].concat(parseWarnings, warnings || []);

          _this2._emit('import.done', { error: err, warnings: allWarnings });

          done(err, allWarnings);
        });
      });
    }
  }, {
    key: 'getDefinitions',
    value: function getDefinitions() {
      return this._definitions;
    }

    /**
     * Return active view.
     *
     * @return {View}
     */

  }, {
    key: 'getActiveView',
    value: function getActiveView() {
      return this._activeView;
    }

    /**
     * Get the currently active viewer instance.
     *
     * @return {View}
     */

  }, {
    key: 'getActiveViewer',
    value: function getActiveViewer() {
      var activeView = this.getActiveView();

      return activeView && this._getViewer(activeView);
    }
  }, {
    key: 'getView',
    value: function getView(element) {
      return this._views.filter(function (v) {
        return v.element === element;
      })[0];
    }
  }, {
    key: 'getViews',
    value: function getViews() {
      return this._views;
    }

    /**
     * Export the currently displayed DMN 1.1 diagram as
     * a DMN 1.1 XML document.
     *
     * ## Life-Cycle Events
     *
     * During XML saving the viewer will fire life-cycle events:
     *
     *   * saveXML.start (before serialization)
     *   * saveXML.serialized (after xml generation)
     *   * saveXML.done (everything done)
     *
     * You can use these events to hook into the life-cycle.
     *
     * @param {Object} [options] export options
     * @param {Boolean} [options.format=false] output formated XML
     * @param {Boolean} [options.preamble=true] output preamble
     * @param {Function} done invoked with (err, xml)
     */

  }, {
    key: 'saveXML',
    value: function saveXML(options, done) {
      var _this3 = this;

      if (typeof options === 'function') {
        done = options;
        options = {};
      }

      var definitions = this._definitions;

      if (!definitions) {
        return done(new Error('no definitions loaded'));
      }

      // allow to fiddle around with definitions
      definitions = this._emit('saveXML.start', {
        definitions: definitions
      }) || definitions;

      this._moddle.toXML(definitions, options, function (err, xml) {

        try {
          xml = _this3._emit('saveXML.serialized', {
            error: err,
            xml: xml
          }) || xml;

          _this3._emit('saveXML.done', {
            error: err,
            xml: xml
          });
        } catch (e) {
          console.error('error in saveXML life-cycle listener', e);
        }

        done(err, xml);
      });
    }

    /**
     * Register an event listener
     *
     * Remove a previously added listener via {@link #off(event, callback)}.
     *
     * @param {String} event
     * @param {Number} [priority]
     * @param {Function} callback
     * @param {Object} [that]
     */

  }, {
    key: 'on',
    value: function on() {
      var _eventBus;

      (_eventBus = this._eventBus).on.apply(_eventBus, arguments);
    }

    /**
     * De-register an event listener
     *
     * @param {String} event
     * @param {Function} callback
     */

  }, {
    key: 'off',
    value: function off() {
      var _eventBus2;

      (_eventBus2 = this._eventBus).off.apply(_eventBus2, arguments);
    }

    /**
     * Register a listener to be invoked once only.
     *
     * @param {String} event
     * @param {Number} [priority]
     * @param {Function} callback
     * @param {Object} [that]
     */

  }, {
    key: 'once',
    value: function once() {
      var _eventBus3;

      (_eventBus3 = this._eventBus).once.apply(_eventBus3, arguments);
    }
  }, {
    key: 'attachTo',
    value: function attachTo(parentNode) {

      // unwrap jQuery if provided
      if (parentNode.get && parentNode.constructor.prototype.jquery) {
        parentNode = parentNode.get(0);
      }

      if (typeof parentNode === 'string') {
        parentNode = domQuery(parentNode);
      }

      parentNode.appendChild(this._container);

      this._emit('attach', {});
    }
  }, {
    key: 'detach',
    value: function detach() {
      this._emit('detach', {});

      domRemove(this._container);
    }
  }, {
    key: 'destroy',
    value: function destroy() {
      var _this4 = this;

      Object.keys(this._viewers).forEach(function (viewerId) {
        var viewer = _this4._viewers[viewerId];

        safeExecute(viewer, 'destroy');
      });

      domRemove(this._container);
    }
  }, {
    key: '_init',
    value: function _init(options) {
      this._options = options;

      this._moddle = this._createModdle(options);

      this._viewers = {};
      this._views = [];

      var container = domify('<div class="dmn-js-parent"></div>');

      var containerOptions = assign({}, DEFAULT_CONTAINER_OPTIONS, options);

      assign(container.style, {
        width: ensureUnit(containerOptions.width),
        height: ensureUnit(containerOptions.height),
        position: containerOptions.position
      });

      this._container = container;

      if (options.container) {
        this.attachTo(options.container);
      }
    }

    /**
     * Open diagram element.
     *
     * @param  {ModdleElement}   element
     * @param  {Function} [done]
     */

  }, {
    key: 'open',
    value: function open(view) {
      var done = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;

      this._switchView(view, done);
    }
  }, {
    key: '_setDefinitions',
    value: function _setDefinitions(definitions) {
      this._definitions = definitions;

      this._updateViews();
    }
  }, {
    key: '_updateViews',


    /**
     * Recompute changed views after elements in
     * the DMN diagram have changed.
     */
    value: function _updateViews() {

      var definitions = this._definitions;

      if (!definitions) {
        this._views = [];
        this._switchView(null);

        return;
      }

      var viewProviders = this._getViewProviders();

      var displayableElements = [definitions].concat(_toConsumableArray(definitions.drgElements || []));

      // compute list of available views
      this._views = displayableElements.reduce(function (views, element) {

        var provider = find(viewProviders, function (provider) {
          if (typeof provider.opens === 'string') {
            return provider.opens === element.$type;
          } else {
            return provider.opens(element);
          }
        });

        if (!provider) {
          return views;
        }

        var view = {
          element: element,
          type: provider.id
        };

        return [].concat(_toConsumableArray(views), [view]);
      }, []);

      var activeView = this._activeView,
          newActiveView;

      if (activeView) {
        // check the new active view
        newActiveView = find(this._views, function (v) {
          return viewsEqual(activeView, v);
        }) || this._getInitialView(this._views);

        if (viewsEqual(activeView, newActiveView)) {
          // active view changed
          this._activeView = newActiveView;
        } else {
          // active view got deleted
          return this._switchView(null);
        }
      }

      this._viewsChanged();
    }
  }, {
    key: '_getInitialView',
    value: function _getInitialView(views) {
      return views[0];
    }

    /**
     * Switch to another view.
     *
     * @param  {View} newView
     * @param  {Function} [done]
     */

  }, {
    key: '_switchView',
    value: function _switchView(newView) {
      var _this5 = this;

      var done = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;


      var complete = function complete(err, warnings) {
        _this5._viewsChanged();

        done(err, warnings);
      };

      var activeView = this.getActiveView(),
          activeViewer;

      var newViewer = newView && this._getViewer(newView),
          element = newView && newView.element;

      if (activeView) {
        activeViewer = this._getViewer(activeView);

        if (activeViewer !== newViewer) {
          safeExecute(activeViewer, 'clear');

          activeViewer.detach();
        }
      }

      this._activeView = newView;

      if (newViewer) {

        if (activeViewer !== newViewer) {
          newViewer.attachTo(this._container);
        }

        this._emit('import.render.start', {
          view: newView,
          element: element
        });

        return newViewer.open(element, function (err, warnings) {

          _this5._emit('import.render.complete', {
            view: newView,
            error: err,
            warnings: warnings
          });

          complete(err, warnings);
        });
      }

      // no active view
      complete();
    }
  }, {
    key: '_getViewer',
    value: function _getViewer(view) {

      var type = view.type;

      var viewer = this._viewers[type];

      if (!viewer) {
        viewer = this._viewers[type] = this._createViewer(view.type);

        this._emit('viewer.created', {
          type: type,
          viewer: viewer
        });
      }

      return viewer;
    }
  }, {
    key: '_createViewer',
    value: function _createViewer(id) {

      var provider = find(this._getViewProviders(), function (provider) {
        return provider.id === id;
      });

      if (!provider) {
        throw new Error('no provider for view type <' + id + '>');
      }

      var Viewer = provider.constructor;

      var providerOptions = this._options[id] || {};
      var commonOptions = this._options.common || {};

      return new Viewer(_extends({}, commonOptions, providerOptions, {
        additionalModules: [].concat(_toConsumableArray(providerOptions.additionalModules || []), [{
          _parent: ['value', this],
          moddle: ['value', this._moddle]
        }])
      }));
    }

    /**
     * Emit an event.
     */

  }, {
    key: '_emit',
    value: function _emit() {
      var _eventBus4;

      (_eventBus4 = this._eventBus).fire.apply(_eventBus4, arguments);
    }
  }, {
    key: '_createModdle',
    value: function _createModdle(options) {
      return new DmnModdle(options.moddleExtensions || {});
    }

    /**
     * Return the list of available view providers.
     *
     * @abstract
     *
     * @return {Array<ViewProvider>}
     */

  }, {
    key: '_getViewProviders',
    value: function _getViewProviders() {
      return [];
    }
  }]);

  return Manager;
}();

// helpers //////////////////////

export default Manager;
function noop() {}

/**
 * Ensure the passed argument is a proper unit (defaulting to px)
 */
function ensureUnit(val) {
  return val + (isNumber(val) ? 'px' : '');
}

function checkValidationError(err) {

  // check if we can help the user by indicating wrong DMN 1.1 xml
  // (in case he or the exporting tool did not get that right)

  var pattern = /unparsable content <([^>]+)> detected([\s\S]*)$/,
      match = pattern.exec(err.message);

  if (match) {
    err.message = 'unparsable content <' + match[1] + '> detected; ' + 'this may indicate an invalid DMN 1.1 diagram file' + match[2];
  }

  return err;
}

function find(arr, fn) {
  return arr.filter(fn)[0];
}

function viewsEqual(a, b) {

  if (typeof a === 'undefined') {
    if (typeof b === 'undefined') {
      return true;
    } else {
      return false;
    }
  }

  if (typeof b === 'undefined') {
    return false;
  }

  // compare by element _or_ element ID equality
  return a.element === b.element || a.element.id === b.element.id;
}

function safeExecute(viewer, method) {
  if (typeof viewer[method] === 'function') {
    viewer[method]();
  }
}
//# sourceMappingURL=Manager.js.map